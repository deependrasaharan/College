================================================================================
                    ARTIFICIAL INTELLIGENCE LABORATORY
                              PRACTICAL REPORT
================================================================================

PRACTICAL NO: 1

TITLE: Understanding and Implementation of Breadth-First Search (BFS) Algorithm

NAME: [Your Name]
ROLL NO: [Your Roll Number]
DATE: November 3, 2025

================================================================================
                                   AIM
================================================================================

To understand and implement the Breadth-First Search (BFS) algorithm for graph 
traversal with an interactive graphical user interface for graph construction 
and visualization.

================================================================================
                               INTRODUCTION
================================================================================

Breadth-First Search (BFS) is a fundamental graph traversal algorithm that 
explores vertices level by level. It starts at a source vertex and explores 
all neighboring vertices at the present depth before moving to vertices at the 
next depth level.

RELEVANCE TO ARTIFICIAL INTELLIGENCE:
BFS is a core uninformed search strategy in AI, used for systematic exploration 
of state spaces. In AI, problems are represented as graphs where nodes are 
states and edges are actions. BFS guarantees finding the shortest solution path, 
making it essential for:

• AI Planning - Finding optimal action sequences
• Robot Navigation - Shortest path in grid environments  
• Puzzle Solving - Minimum moves to goal state
• Game AI - Level-by-level game tree exploration

This practical implements BFS with an interactive GUI for graph construction 
and visualization, demonstrating how AI search algorithms systematically explore 
problem spaces.

================================================================================
                                  THEORY
================================================================================

BFS IN AI:
BFS is an uninformed search strategy in AI that guarantees COMPLETENESS 
(finds solution if exists) and OPTIMALITY (finds shortest path).

GRAPH REPRESENTATION:
In AI, graphs model problem spaces where:
- Nodes = States (problem configurations)
- Edges = Actions (transitions between states)

This implementation uses Adjacency List representation:
• Space Complexity: O(V + E) - efficient for sparse graphs
• Structure: Dictionary mapping each node to list of neighbors

BFS ALGORITHM:
1. Initialize: visited set, queue (FRONTIER), result list
2. Add start node to queue and mark visited
3. While queue not empty:
   a. Dequeue current node (EXPAND)
   b. Add to result
   c. For each unvisited neighbor (GENERATE successors):
      - Mark visited (EXPLORED set)
      - Add to queue (FRONTIER)
4. Return traversal order

COMPLEXITY ANALYSIS:
• Time Complexity: O(V + E)
  - V = number of vertices, E = number of edges
  - Each vertex visited once, each edge explored once
  - AI notation: O(b^d) where b = branching factor, d = depth

• Space Complexity: O(V)
  - Queue stores at most one level of nodes
  - Visited set stores all discovered nodes
  - AI notation: O(b^d) for frontier storage

KEY PROPERTIES:
• Uses Queue (FIFO) data structure
• Level-order traversal
• Guarantees shortest path in unweighted graphs
• Complete for finite graphs
• Optimal for unit-cost actions

COMPARISON WITH DFS:
┌─────────────────┬──────────────────┬──────────────────┐
│   Property      │       BFS        │       DFS        │
├─────────────────┼──────────────────┼──────────────────┤
│ Data Structure  │ Queue (FIFO)     │ Stack (LIFO)     │
│ Traversal       │ Level-by-level   │ Depth-first      │
│ Completeness    │ Yes              │ No (infinite)    │
│ Optimality      │ Yes              │ No               │
│ Time            │ O(V + E)         │ O(V + E)         │
│ Space           │ O(V) - High      │ O(h) - Low       │
└─────────────────┴──────────────────┴──────────────────┘
h = height of tree

================================================================================
                                ALGORITHM
================================================================================

PSEUDOCODE:

BFS(graph, start_vertex):
    Initialize:
        visited = empty set
        queue = empty queue
        result = empty list
    
    visited.add(start_vertex)
    queue.enqueue(start_vertex)
    
    while queue is not empty:
        current = queue.dequeue()
        result.append(current)
        
        for each neighbor of current:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
    
    return result


STEP-BY-STEP EXAMPLE:

Consider the graph:
        1
       / \
      2   3
     / \
    4   5

Starting BFS from vertex 1:

Step 1: Visit 1, Queue: [1], Visited: {1}
Step 2: Dequeue 1, explore neighbors 2,3
        Queue: [2, 3], Visited: {1, 2, 3}
Step 3: Dequeue 2, explore neighbors 4,5
        Queue: [3, 4, 5], Visited: {1, 2, 3, 4, 5}
Step 4: Dequeue 3 (no unvisited neighbors)
        Queue: [4, 5], Visited: {1, 2, 3, 4, 5}
Step 5: Dequeue 4 (no unvisited neighbors)
        Queue: [5], Visited: {1, 2, 3, 4, 5}
Step 6: Dequeue 5 (no unvisited neighbors)
        Queue: [], Visited: {1, 2, 3, 4, 5}

BFS Traversal Order: 1 → 2 → 3 → 4 → 5

================================================================================
                              IMPLEMENTATION
================================================================================

PROGRAM FEATURES:
1. Automatic node generation (random or manual values)
2. Automatic edge generation with validation
3. Manual node and edge addition
4. Interactive canvas-based graph building
5. Visual BFS animation with color coding
6. Graph statistics and adjacency list display
7. Node and edge deletion capabilities
8. Circular auto-layout for clean visualization

DATA STRUCTURES USED:
• Set - For storing nodes (O(1) lookup)
• Dictionary - For adjacency list representation
• Deque - For BFS queue operations
• List - For storing edges and traversal order

KEY CODE SNIPPETS:

1. GRAPH CLASS STRUCTURE:
---------------------------
class Graph:
    def __init__(self):
        self.adjacency_list = {}  # {node: [neighbors]}
        self.nodes = set()         # Set of all nodes
    
    def add_node(self, value):
        if value not in self.nodes:
            self.nodes.add(value)
            self.adjacency_list[value] = []
            return True
        return False
    
    def add_edge(self, node1, node2):
        if node1 in self.nodes and node2 in self.nodes:
            if node2 not in self.adjacency_list[node1]:
                self.adjacency_list[node1].append(node2)
                self.adjacency_list[node2].append(node1)
                return True
        return False


2. BFS TRAVERSAL IMPLEMENTATION:
---------------------------------
def bfs_traversal(self, start_node):
    if start_node not in self.nodes:
        return []
    
    visited = set()
    queue = deque([start_node])
    traversal_order = []
    
    visited.add(start_node)
    
    while queue:
        current = queue.popleft()
        traversal_order.append(current)
        
        # Visit all unvisited neighbors
        for neighbor in sorted(self.adjacency_list[current]):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return traversal_order


3. VALIDATION FUNCTIONS:
-------------------------
def node_exists(self, value):
    return value in self.nodes

def edge_exists(self, node1, node2):
    if node1 in self.nodes and node2 in self.nodes:
        return node2 in self.adjacency_list[node1]
    return False


4. CIRCULAR LAYOUT ALGORITHM:
------------------------------
def arrange_nodes_circle(self):
    nodes = sorted(self.graph.nodes)
    n = len(nodes)
    
    center_x = canvas_width // 2
    center_y = canvas_height // 2
    radius = min(canvas_width, canvas_height) // 2 - 60
    
    for i, value in enumerate(nodes):
        angle = 2 * math.pi * i / n - math.pi / 2
        x = center_x + radius * math.cos(angle)
        y = center_y + radius * math.sin(angle)
        self.node_positions[value] = (x, y)


VALIDATION IMPLEMENTED:
• Integer-only input for node values
• No duplicate nodes allowed
• No duplicate edges allowed
• No self-loops (edge from node to itself)
• Minimum 2 nodes required for edge creation
• Maximum edges enforced: n(n-1)/2 for undirected graph

================================================================================
                                  OUTPUT
================================================================================

The program provides both CLI and GUI versions:

CLI VERSION:
------------
[Screenshot 1: Main menu showing 8 options]
[Screenshot 2: Automatic node generation with random values]
[Screenshot 3: Automatic edge generation]
[Screenshot 4: Display graph showing adjacency list]
[Screenshot 5: BFS traversal result showing traversal order]

GUI VERSION:
------------
[Screenshot 6: Main GUI interface with canvas and control panel]
[Screenshot 7: Graph with nodes arranged in circular layout]
[Screenshot 8: BFS animation showing color-coded nodes]
  - Light Blue: Normal nodes
  - Orange: Selected nodes
  - Light Green: Nodes in queue (discovered)
  - Green: Processed nodes (visited)
[Screenshot 9: Graph statistics popup window]
[Screenshot 10: Adjacency list display in separate window]

SAMPLE OUTPUT SCREENS:

Screen 1 - Graph Construction:
  Graph created with 8 nodes: [10, 20, 30, 40, 50, 60, 70, 80]
  12 edges connecting various nodes
  Circular layout applied automatically

Screen 2 - BFS Execution:
  Starting Node: 10
  BFS Traversal Order: 10 → 20 → 30 → 40 → 50 → 60 → 70 → 80
  
  Animation shows:
  Step 1: Node 10 turns green (processed)
  Step 2: Nodes 20, 30 turn light green (queued)
  Step 3: Node 20 turns green, neighbors queued
  ... (continues until all reachable nodes visited)

Screen 3 - Graph Statistics:
  Total Nodes: 8
  Total Edges: 12
  Maximum Possible Edges: 28
  Graph Density: 12/28 = 42.86%

Screen 4 - Adjacency List:
  10 → [20, 30]
  20 → [10, 40, 50]
  30 → [10, 60]
  40 → [20, 70]
  50 → [20, 80]
  60 → [30, 70]
  70 → [40, 60, 80]
  80 → [50, 70]

================================================================================
                              OBSERVATIONS
================================================================================

1. BFS explores all vertices at distance k before exploring vertices at 
   distance k+1 from the source vertex.

2. The algorithm guarantees the shortest path in terms of number of edges 
   in an unweighted graph.

3. Visual representation helps understand the level-order traversal nature 
   of BFS.

4. Queue data structure is essential for maintaining the order of exploration.

5. Time complexity remains O(V+E) regardless of graph density, making it 
   efficient for sparse graphs.

6. The visited set prevents re-processing of vertices, ensuring each vertex 
   is visited exactly once.

7. For disconnected graphs, BFS will only traverse the connected component 
   containing the start vertex.

8. Memory usage increases with breadth of graph due to queue storage.

================================================================================
                              RESULT & CONCLUSION
================================================================================

RESULTS:
✓ Successfully implemented BFS algorithm with O(V+E) time complexity
✓ Created interactive GUI with graph visualization
✓ Achieved animated BFS traversal with color-coded states
✓ Implemented input validation and error handling
✓ Verified correctness with multiple test cases

CONCLUSION:
This practical successfully demonstrates BFS as a fundamental AI search 
algorithm through an interactive GUI application.

TECHNICAL ACHIEVEMENTS:
• Correct BFS using queue (FIFO) data structure
• Adjacency list representation for efficient storage
• Real-time visualization of algorithm execution
• Manual and automatic graph generation

KEY LEARNINGS:
1. BFS guarantees shortest path in unweighted graphs
2. Queue structure ensures level-by-level exploration
3. Visited set prevents cycles and redundant exploration
4. Completeness and optimality properties of uninformed search
5. Visual understanding of state space exploration

PRACTICAL SIGNIFICANCE:
• Foundation for advanced AI search algorithms
• Understanding of graph-based problem solving
• Experience with GUI implementation for algorithm visualization
• Translation of theoretical concepts to working code

================================================================================
                            SIGNATURE
================================================================================

Student Signature: _________________          Date: _________________

Faculty Signature: _________________          Date: _________________

================================================================================
                              END OF REPORT
================================================================================
